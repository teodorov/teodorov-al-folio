<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>From Zero to Model-Checking</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme && theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar && sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="00_foreword.html"><strong aria-hidden="true">1.</strong> Foreword</a></li><li class="chapter-item expanded "><a href="01_traversals.html"><strong aria-hidden="true">2.</strong> Chapter 1: Traversals</a></li><li class="chapter-item expanded "><a href="02_piecewise_relations.html"><strong aria-hidden="true">3.</strong> Chapter 2: Piecewise Relations</a></li><li class="chapter-item expanded "><a href="03_soup_dsl.html"><strong aria-hidden="true">4.</strong> Chapter 3: Soup DSL</a></li><li class="chapter-item expanded "><a href="04_dependent_semantics.html"><strong aria-hidden="true">5.</strong> Chapter 4: Dependent Semantics</a></li><li class="chapter-item expanded "><a href="05_synchronous_composition.html"><strong aria-hidden="true">6.</strong> Chapter 5: Synchronous Composition</a></li><li class="chapter-item expanded "><a href="06_liveness_verification.html"><strong aria-hidden="true">7.</strong> Chapter 6: Liveness Verification</a></li><li class="chapter-item expanded "><a href="07_algorithms_are_dependent.html"><strong aria-hidden="true">8.</strong> Chapter 7: Algorithms are Dependent</a></li><li class="chapter-item expanded "><a href="08_underapproximations.html"><strong aria-hidden="true">9.</strong> Chapter 8: Underapproximations</a></li><li class="chapter-item expanded "><a href="09_conclusion.html"><strong aria-hidden="true">10.</strong> Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">From Zero to Model-Checking</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="/assets/img/z2mc/02MC.png" alt="02MC" /></p>
<h1 id="foreword"><a class="header" href="#foreword">Foreword</a></h1>
<p>This sequel is intended as a hands-on introduction to formal verification by model-checking (mostly explicit-state), even though a more sophisticated reader might see opportunities for symbolic or mixed explicit-symbolic verification.</p>
<p>After engaging with the content here a <strong>reader interested in using formal verification</strong> shall have the necessary background to understand deeply some of the existing model-checking tools: <strong>TLA+</strong>, SPIN, UPPAAL.</p>
<p>After engaging with the content here a <strong>reader working on language design</strong> might be willing to try designing (and implementing) the semantics of the language through the piecewise relation abstraction, which offers a bridge between behavioral language semantics (seen as specifications) and behavioral verification tools.</p>
<h2 id="games"><a class="header" href="#games">Games</a></h2>
<ul>
<li><a href="https://fmfun.github.io/Papers-2019/Schlingloff.pdf">Teaching Model Checking via Games and Puzzles</a></li>
<li><a href="https://iopscience.iop.org/article/10.1088/1742-6596/1679/3/032020">Model Checking Games and a Genome Sequence Search</a></li>
<li><a href="https://www.cs.colostate.edu/~france/CS614/Slides/ModelCheckingChapter4.pdf">Principles of Model Checking: Regular Properties</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph-traversal"><a class="header" href="#graph-traversal">Graph Traversal</a></h1>
<p><strong>Principles</strong>:</p>
<ul>
<li>Isolate the algorithms from the data structures they operate on.</li>
<li>Explicitly state the hypotheses under which an algorithm works. And build up bridges toward satisfying those hypotheses.</li>
</ul>
<p>In this chapter, we will introduce graphs and a graph traversal algorithm.
We will keep it as simple as possible since the concepts here are well-known with rich literature.</p>
<p><img src="/assets/img/z2mc/overview_01.png" alt="Progress Overview" />{: width=&quot;400&quot; style=&quot;display:block; margin-left:auto; margin-right:auto&quot;}</p>
<ol>
<li>Graph and Graph Representation</li>
<li>[A] Graph <strong>Traversals</strong> -- [M] Explicit graph</li>
<li>BFS</li>
<li>Iterative</li>
<li>Independent of the model <code>roots(); next()</code></li>
<li>OnEntry callback --&gt; See another blog entry for a more generic version</li>
</ol>
<h2 id="a-rooted-graph-and-an-explicit-graph-data-structure"><a class="header" href="#a-rooted-graph-and-an-explicit-graph-data-structure">A Rooted Graph and an Explicit Graph Data Structure</a></h2>
<p>A graph is defined as a tuple <code>G=(V, E)</code> where <code>V</code> is an arbitrary set of vertices, and <code>E</code> is a binary relation between the elements in <code>V</code>.
For technical reasons, that will become apparent later, we will allow both self-loops and duplicate edges.
For our purposes, we enrich the previous graph definition with <code>R ⊆ V</code> the multiset of roots of the graph. The roots of a graph are the vertices that provide access to the connected components of the graph. Sometimes <code>R</code> can be just a set, however, the more relaxed multiset concept allows for simpler, less constrained implementations (a list of nodes for instance).
Thus a rooted graph <code>RG</code> is defined as <code>RG=(V, E, R)</code>.</p>
<h3 id="dictionary-based-rooted-graph"><a class="header" href="#dictionary-based-rooted-graph">Dictionary-based Rooted Graph</a></h3>
<p>To make it simple, we will represent the rooted graph structure by encoding the graph as an adjacency list using a <a href="https://docs.python.org/3.11/library/stdtypes.html#mapping-types-dict">dictionary</a>.
The keys of the dictionary will be the vertices of the graph. To each vertex we will associate a <a href="https://docs.python.org/3.11/library/stdtypes.html#list">list</a> of nodes, which are directly reachable from the vertex.</p>
<pre><code class="language-python">graph = {
  1: [2, 3],
  2: [3, 4]
}
</code></pre>
<p>To obtain the rooted graph structure we complement the dictionary with another list of vertices, the roots.</p>
<pre><code class="language-python">roots = [1, 2].
</code></pre>
<p>The rooted graph structure is then obtained by encapsulating these to fields in an object. Let's first define a DictionaryRootedGraph class, which allows building the objects that we need.</p>
<pre><code class="language-python">class DictionaryRootedGraph:
  def __init__(self, graph, roots):
    self.graph = graph
    self.roots = roots
</code></pre>
<p>With this, we already have a small domain-specific language (embedded in Python), which allows us to build rooted graphs. Let's see an example</p>
<pre><code class="language-python">graph1 = DictionaryRootedGraph(
    {
        1: [2, 3],
        2: [3, 4]
    },
    [1, 3]
)
</code></pre>
<h2 id="breadth-first-traversal"><a class="header" href="#breadth-first-traversal">Breadth-First Traversal</a></h2>
<p><img src="/assets/img/z2mc/traversal_concepts.png" alt="Traversal Concepts" />{: width=&quot;400&quot; style=&quot;display:block; margin-left:auto; margin-right:auto&quot;}</p>
<pre><code class="language-ruby">traversal K {}      = K
traversal K {x} ∪ F = traversal K F                            if x ∈ K
traversal K {x} ∪ F = traversal ({x} ∪ K) ((neighbors x) ∪ F)  if x ∉ K

dfs K []        = K
dfs K (x::L)    = dfs K L                            if x ∈ K
dfs K (x::L)    = dfs ({x} ∪ K) ((neighbors x) ++ L) if x ∉ K

bfs K []        = K
bfs K (x::L)    = dfs K L                            if x ∈ K
bfs K (x::L)    = dfs ({x} ∪ K) (L ++ (neighbors x)) if x ∉ K
</code></pre>
<p><img src="/assets/img/z2mc/breadthFirstTraversal_action.png" alt="BreadthFirstTraversal Action" />{: width=&quot;200&quot; style=&quot;display:block; margin-left:auto; margin-right:auto&quot;}</p>
<pre><code class="language-scala">breadthFirstTraversal(rootedGraph):
    I = True
    K = ∅
    F = []
    WHILE F ≠ ∅ ∨ I DO
        N = IF I THEN rootedGraph.roots ELSE rootedGraph.graph[F.dequeue()]
        I = False
        FORALL n ∈ N
            IF n ∉ K THEN 
                K = K ∪ {n} 
                F = F ∪ {n}
    RETURN K
</code></pre>
<p><strong>NOTE:</strong> For implementing a set in Python use the <a href="https://docs.python.org/3.11/library/stdtypes.html#set-types-set-frozenset">set data structure</a>.</p>
<p><strong>NOTE:</strong> For implementing the FIFO queue in Python use the <a href="https://docs.python.org/3.11/library/collections.html#collections.deque">deque (<strong>D</strong>ouble-<strong>E</strong>nded <strong>Que</strong>ue) data structure</a> data structure. The deque is a list-like sequence optimized for data access near its endpoints.</p>
<p>Implement this algorithm in Python, and test it. Don't forget to use the debugger to understand what is happening.
Amongst your tests think of edge cases for instance:</p>
<ul>
<li><code>breadthFirstTraversal(DictionaryRootedGraph())</code></li>
<li><code>breadthFirstTraversal(DictionaryRootedGraph({}, nil))</code></li>
<li><code>breadthFirstTraversal(DictionaryRootedGraph(nil, []))</code></li>
<li><code>breadthFirstTraversal(DictionaryRootedGraph({1: nil}, []))</code></li>
</ul>
<p>Fix the <strong>algorithm</strong> to pass all tests.</p>
<h3 id="abstracting-over-the-graph"><a class="header" href="#abstracting-over-the-graph">Abstracting Over the Graph</a></h3>
<p>Why is the algorithm polluted with the implementation details of the <code>DictionaryRootedGraph</code>?</p>
<p>The key idea here is to look at the algorithm implementation and try to abstract over the queries on the <code>DictionaryRootedGraph</code> data structure by introducing methods, which will hide the data structure-specific details. We need to analyze the algorithm to understand what queries it performs on our data structure. In our case, the answer is rather simple since our <code>breadthFirstTraversal</code> uses the rootedGraph only at line 6, where performs two queries:</p>
<ol>
<li>If we are at the beginning (during the initialization phase), we need the <strong>roots</strong> of the graph - our entries in the graph.</li>
<li>In the subsequent steps, for any vertex <code>v</code> obtained from the frontier (<code>F.dequeue()</code>) we need to obtain its <strong>neighbors</strong> (the vertices that we get by following the edges starting at <code>v</code>).</li>
</ol>
<p>Let's add these two methods to the <code>DictionaryRootedGraph</code> class, and then update the <code>breadthFirstTraversal</code> to use these methods, instead of directly using instance variable accesses.</p>
<pre><code class="language-python">class DictionaryRootedGraph:
    def __init__(self, graph, roots):
        self._graph = graph
        self._roots = roots

    def roots(self):
        return self._roots

    def neighbors(self, vertex):
        return self._graph[vertex]
</code></pre>
<h4 id="different-data-structures"><a class="header" href="#different-data-structures">Different Data Structures</a></h4>
<p>Let's say now that we don't like this rooted graph implementation because I have better data-structure implementations:</p>
<ul>
<li>for dense graphs (graphs with many edges) a Matrix (a bitmap) representation will be more compact.</li>
<li>for large graphs with few edges, a sparse matrix encoding of the graph is more compact.</li>
<li>storing the edges explicitly in a list is easy to parse.</li>
</ul>
<p>To allow our algorithm to work with different encodings of the graph </p>
<p>Based on this analysis, we can introduce the <em>abstract</em> concept of <code>RootedGraph</code> that will encapsulate (group together) these two functions.</p>
<pre><code class="language-python">class RootedGraph:
    def roots(self): pass
    def neighbors(self, vertex): pass
</code></pre>
<p><strong>NOTE:</strong> By inheriting from ABC and adding the <code>@abstractmethod</code> annotation we can ensure that the RootedGraph abstract class cannot be instantiated directly.</p>
<p>Python uses the duck-typing principle: <em>&quot;If it walks like a duck and it quacks like a duck, then it must be a duck&quot;</em>.
Following this principle, in our case, that means that any object that implements the <code>roots(self)</code> and <code>next(self, vertex)</code> methods are considered <strong>implicitly</strong> as instances of the <code>RootedGraph</code> abstract class. Furthermore, we do not need to define the RootedGraph abstract class at all. Nevertheless doing so greatly improves the readability of the code, as the abstract class clearly defines the public API of any <code>RootedGraph</code> instance. To be even more explicit we can explicitly define the DictionaryRootedGraph class to be an instance of the <code>RootedGraph</code> abstract class.</p>
<pre><code class="language-python">class DictionaryRootedGraph(RootedGraph):
</code></pre>
<p>The <code>EdgeListRootedGraph</code> is a different data structure that can represent the graph with a simple list of edges. The edges in the list are encoded as a Python <a href="https://docs.python.org/3.11/library/stdtypes.html#tuple">tuple</a> <code>(source, destination)</code>, where the <code>source</code> object represents the source vertex of the edge and the <code>destination</code> object represents the target vertex of the edge.
Besides the edge list, our `RootedGraph`` needs the roots of the graph, we will represent them as a list as earlier.</p>
<p>Create the <code>EdgeListRootedGraph</code></p>
<p>Here is a simple graph</p>
<pre><code class="language-python">graph = EdgeListRootedGraph(
    [
        (1, 2),
        (1, 3),
        (2, 3),
        (2, 4)
    ],
    [1,3]
)
</code></pre>
<p>What do we need to do so that we can use our <code>BFS</code> algorithm with this new data structure?
What are the differences between the <code>DictionaryRootedGraph</code> and the <code>EdgeListRootedGraph</code>?</p>
<p>The <code>EdgeListRootedGraph</code> instances are easier to create from a file containing the roots and the edge list.</p>
<pre><code class="language-python">1 3 #roots
1 2
1 3
2 3
2 4
</code></pre>
<p>Write a <code>reader</code> factory that creates an <code>EdgeListRootedGraph</code> from such a file.</p>
<p><img src="/assets/img/z2mc/rooted_graph.png" alt="RootedGraph class hierarchy" />{: width=&quot;400&quot; style=&quot;display:block; margin-left:auto; margin-right:auto&quot;}</p>
<h4 id="more-generic-vertex-types"><a class="header" href="#more-generic-vertex-types">More Generic Vertex Types</a></h4>
<p>Up until now, we have used only integer objects to represent the graph vertices. But in the long run, we will want to handle generic objects.</p>
<p>Try creating a graph of <code>Persons(first_name, family_name)</code> identified by their name. The relations in the graph represent that a <code>Person</code> <code>knows</code> another <code>Person</code>.
Run the previous reachability algorithm on this graph. If we have a relation <code>Person(a, b) -&gt; Person(a, b)</code> what is the result of the reachability query? Why do we have <code>Person(a, b)</code> twice in the result? How can we fix that?</p>
<p>Object <strong>Identity</strong> versus object <strong>Equality</strong>, and the set implementation in Python.</p>
<p>To solve this problem we need to enrich our objects with a domain-specific notion of equality. What makes two <code>Person</code> instances equal?</p>
<pre><code class="language-python">class Person:
    ...
    def __eq__(self, other):
        ...
    def __hash__(self):
        ...
</code></pre>
<h3 id="breadth-first-search"><a class="header" href="#breadth-first-search">Breadth-First Search</a></h3>
<p><img src="/assets/img/z2mc/breadthFirstSearch_action.png" alt="BreadthFirstSearch Action" />{: width=&quot;200&quot; style=&quot;display:block; margin-left:auto; margin-right:auto&quot;}</p>
<pre><code class="language-scala">breadthFirstSearch(graph, on_entry, opaque):
    I = True
    K = ∅
    F = []
    WHILE F ≠ ∅ ∨ I DO
        N = IF I THEN graph.roots() ELSE graph.neighbours(F.dequeue())
        I = False
        FORALL n ∈ N
            IF n ∉ K THEN
                terminate = on_entry(n, opaque)
                IF terminate THEN
                    RETURN (opaque, K)        
                K = K ∪ {n} 
                F = F ∪ {n}
    RETURN (opaque, K)
</code></pre>
<hr>
<h2 id="intensional-graphs-hanoi-example"><a class="header" href="#intensional-graphs-hanoi-example">Intensional Graphs: Hanoi Example</a></h2>
<p><img src="/assets/img/z2mc/overview_01_hanoi.png" alt="Progress Overview" />{: width=&quot;400&quot; style=&quot;display:block; margin-left:auto; margin-right:auto&quot;}</p>
<p>Up until now, we have used only extensional graph representations. But there is no fundamental limit precluding us from using also intensional graph representations. These are graphs that are defined by giving a procedure that can be followed to obtain the graph dynamically on request. At this point, we will start to see the power of our query-based graph manipulations. Here instead of enumerating all the vertices and edges of the graph, we will provide <strong>smart</strong> implementation of the <code>roots</code> and <code>neighbors</code> methods to generate <em>special</em> graphs programmatically that will then be analyzed by our algorithms.</p>
<p>To make this section a bit concrete we will create a NBits game. The aim is to encode the game state as graph vertices and the game actions, that link two game states, as edges. After encoding the game rules we will look for the solution by simply calling our breadth-first search algorithm.</p>
<pre><code class="language-python">class NBits:
    def __init__(self, n, ini: list):
        self.n = n
        self.ini = ini
        self.accepting = accepting

    def roots(self):
        return self.ini

    def neighbors(self, configuration: int):
        targets = []
        for i in range(self.n):
            if ((configuration &gt;&gt; i) &amp; 1) &gt; 0:
                target = configuration &amp; ~(1 &lt;&lt; i)
            else:
                target = configuration | (1 &lt;&lt; i)
            targets.append(target)
        return targets
</code></pre>
<p>Now we have these steps to follow:</p>
<ol>
<li>Define what is a configuration
<ol>
<li><code>def __eq__(self, other):</code></li>
<li><code>def __hash__(self):</code></li>
</ol>
</li>
<li>Define the rooted graph API
<ol>
<li>what is the list of roots?</li>
<li>write an algorithm that generates the neighbors of a given configuration</li>
</ol>
</li>
<li>Define the query</li>
</ol>
<pre><code class="language-python">if __name__ == '__main__':
    nbits = NBits(10, [0])
    (target, k) = bfsSearch(nbits, lambda x: x == 5)
</code></pre>
<p><strong>Exercise:</strong></p>
<ul>
<li>Implement Tower of Hanoi Game</li>
</ul>
<p><strong>Practical situation:</strong> Going beyond simple search. <a href="https://academic.oup.com/comjnl/article-pdf/37/5/429/988918/370429.pdf">Giddy, Jonathan P., and Reihaneh Safavi-Naini. &quot;Automated cryptanalysis of transposition ciphers.&quot; The Computer Journal 37.5 (1994): 429-436.</a></p>
<p>This is great, but, how did we get to this solution?</p>
<hr>
<h2 id="building-the-trace"><a class="header" href="#building-the-trace">Building the Trace</a></h2>
<p><img src="/assets/img/z2mc/overview_02.png" alt="Progress Overview" />{: width=&quot;400&quot; style=&quot;display:block; margin-left:auto; margin-right:auto&quot;}
<img src="/assets/img/z2mc/rooted_graph_02.png" alt="ParentTracer is a RootedGraph" />{: width=&quot;400&quot; style=&quot;display:block; margin-left:auto; margin-right:auto&quot;}</p>
<pre><code class="language-python">class ParentTracer(RootedGraph):

    def __init__(self, operand, parents=None):
        self.operand = operand
        self.parents = {} if parents is None else parents

    def roots(self):
        neighbours = self.operand.roots()
        for n in neighbours:
            self.parents[n] = []
        return neighbours

    def neighbors(self, vertex):
        neighbours = self.operand.neighbors(vertex)
        for n in neighbours:
            if self.parents.get(n) is None:
                self.parents[n] = [vertex]
        return neighbours
</code></pre>
<hr>
<div style="break-before: page; page-break-before: always;"></div><h1 id="piecewise-relations"><a class="header" href="#piecewise-relations">Piecewise Relations</a></h1>
<p><img src="/assets/img/z2mc/overview_03.png" alt="Progress Overview" />{: width=&quot;400&quot; style=&quot;display:block; margin-left:auto; margin-right:auto&quot;}</p>
<p>The intensional graph description used in the previous section allowed us to economically encode a whole family of domain-specific graphs (ie. The graphs representing the valid moves allowed by the Tower of Hanoi puzzle).
There are two downsides with this approach that we want to emphasize in this section:</p>
<ol>
<li>The rooted graph abstraction that we have used <strong>abstracts over the graph edges</strong>, which leads to an <strong>imprecise encoding</strong> of graphs with edge annotations. Different workarounds are still possible:
<ol>
<li>define another function <code>edge_data(source, target)-&gt;maybe(annotation)</code> that retrieves the annotation from any pair of related vertices. But this approach precludes multiple edges between two vertices (a,b,x) (a,b,y).</li>
<li>encode the graph of interest differently, ie push the edge annotation to the target vertex. But this can result in an exponential blowup in the resulting graph.</li>
</ol>
</li>
<li>The implementation of the <code>neighbours</code> function in the Tower of Hanoi example has <strong>multiple responsibilities</strong>:
<ol>
<li><em>detect if a disk move is possible</em></li>
<li><em>create the target configuration/vertex</em>. Typically it is cheaper to create the target configuration by
<ol>
<li><em>copying</em> the source configuration</li>
<li><em>changing</em> it according to the move considered</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>To address these limitations we will first decompose the <code>neighbours</code> function in two parts:</p>
<ol>
<li>an <code>enabled: C → set A</code> function that enables to detect the transitions (edges) allowed in the current configuration.</li>
<li>an <code>execute: A → C → set C</code> function that interprets an enabled transition to obtain the target configuration.</li>
</ol>
<p>This decomposition leads us to an abstraction closely resemblinng <strong>piecewise functions</strong>. In mathematics piecewise functions allow the definition of functions by parts, where each part is a function enabled under a specific condition. To ensure that the resulting <strong>piecewise</strong> definition is still a function the <em>set of conditions need to be mutually exclusive</em>. We will <strong>not enforce this exclusivity constraint</strong> which leads to the more generic <strong>piecewise relation</strong> abstraction. Furthermore, we also relax the <strong>functional</strong> constraint on the parts too. Thus we get to a very general definition of a <strong>piecewise relation</strong>, where each part itself is a relation, potentially defined piecewise itself.</p>
<p><strong>Important:</strong> Please note that both <code>enabled</code> and <code>execute</code> are functions with sets as codomains.</p>
<p>Note that we can also define the predicate <code>enabled: A → C → bool</code>, which returns true if an action <code>A</code> is enabled in the configuration <code>C</code>.</p>
<p>To simplify the manipulations these functions will be encapsulated in a new abstraction, which we name the SemanticTransitionRelation (STR).</p>
<ul>
<li>
<p>Leslie Lamport. 1994. The temporal logic of actions. ACM Trans. Program. Lang. Syst. 16, 3 (May 1994), 872–923. https://doi.org/10.1145/177492.177726</p>
</li>
<li>
<p>Valentin Besnard, Matthias Brun, Frédéric Jouault, Ciprian Teodorov, and Philippe Dhaussy. 2018. Unified LTL Verification and Embedded Execution of UML Models. In Proceedings of the 21th ACM/IEEE International Conference on Model Driven Engineering Languages and Systems (MODELS '18). Association for Computing Machinery, New York, NY, USA, 112–122. https://doi.org/10.1145/3239372.3239395</p>
</li>
<li>
<p>Arthur Charguéraud, Adam Chlipala, Andres Erbsen, and Samuel Gruetter. 2023. Omnisemantics: Smooth Handling of Nondeterminism. ACM Trans. Program. Lang. Syst. 45, 1, Article 5 (March 2023), 43 pages. https://doi.org/10.1145/3579834</p>
</li>
</ul>
<p><strong>side question:</strong> Should we use RootedPiecewiseRelation instead of SemanticTransitionRelation?</p>
<pre><code class="language-python">class STR:
    def roots(self): pass
    def enabled(self, configuration): pass
    def execute(self, action, configuration): pass
</code></pre>
<p>To be able to reuse the algorithmic backend that we have already created, we need to somehow convert a STR to an RG abstraction. To achieve this, one approach is based on the <a href="https://en.wikipedia.org/wiki/Adapter_pattern"><em>Adapter design pattern</em></a>. The <strong>adapter</strong>, named <code>STR2RG</code>, is another specialization of our <code>RootedGraph</code> abstraction that implements the RG API based on the STR API as follows:</p>
<pre><code class="language-python">class STR2RG:
    def __init__(self, anSTR):
        self.str = anSTR
    def roots(self):
        return self.str.roots()
    def neighbours(self, v):
        enabled_actions = self.str.enabled(v)
        targets = []
        for a in enabled_actions:
            targets += self.str.execute(a, v)
        return targets
</code></pre>
<p>With this setup we can already model interesting systems. Consider for instance the piecewise relation represented in the following graph:
<img src="images/piecewise_relation_example.png" alt="An example of a piecewise relation" /></p>
<pre><code>f(x) =
    - 1         if x ≥ -2
    - x         if x &gt; 1
    - (x - 5)^2 if x ≥ 2 ∧ x &lt; 6.3
    - -x        if x ≥ 2 ∧ x ≥ 6
    - x-1       if x ≥ 2 ∧ x ≥ 6
</code></pre>
<pre><code>f(x) =
    - 1         if x ≥ -2
    - x         if x &gt; 1
    - g(x) if x ≥ 2 ∧ g(x) =
        - (x - 5)^2 if x &lt; 6.3
        - h(x) if x ≥ 6 ∧ h(x) =
            -x
            -x-1
</code></pre>
<p>This relation can be encoded with the STR-based intensional graph description as follows:</p>
<pre><code class="language-python">    class ExampleSTR:
        def roots(self):
            return [0]
        def enabled(self, configuration):
            x = configuration
            actions = []
            if (x &gt;= -2):
                actions += [lambda x: [1]]
            if (x &gt; 1):
                actions += [lambda x: [x]]
            if (x &gt;= 2):
                actions += [lambda x:
                    r = []
                    if x &lt; 6.3:
                        r.append((x-5)^2)
                    if x &gt;= 6:
                        r.extend([-x, x-1])
                    r
            return actions
        def execute(self, action, configuration):
            return action(configuration)
</code></pre>
<p>Note that in the previous examples, we compute the new configuration (<code>x'</code>) based on the previous value of x.</p>
<pre><code class="language-scala">var x
init ≜ 0
next ≜ x' = 1      if x &gt;= -2
    ∨  x' = x      if x &gt;   1
    ∨   (   x' = (x-5)^2     if x &lt; 6.3
        ∨   (x' = -x ∨ x' = x-1) if x &gt;= 6) if x &gt;= 2
spec ≜ init ∧ ☐next
</code></pre>
<pre><code class="language-python">//PiReDL syntax
def next (x) ≜
| x ≥ -2 ↦ 1
| x &gt;  1 ↦ x
| x ≥  2 ↦
    | x &lt; 6.3 ↦ (x-5)^2
    | x &gt;= 6  ↦
        | -x
        | x - 1
</code></pre>
<p><strong>Interesting side-note:</strong> Following the syntax 'idea' in the previous listing we can get to the TLA+ syntax rather naturally.
Existential quantification <code>∃ x ∈ S, condition</code> ↦ S detect: λ x, condition</p>
<p>One simple yet interesting specification is a one-bit clock, which alternates forever between 0 and 1.</p>
<pre><code class="language-scala">var clock
init ≜ clock = 0
     ∨ clock = 1
tick ≜ clock' = 1 if clock = 0
     ∨ clock' = 0 if clock = 1
spec ≜ init ∧ ☐tick
</code></pre>
<p><code>Flag Alice-Bob</code> Another more interesting example will be the following specification trying to solve the binary mutual exclusion problem between Alice and Bob.</p>
<pre><code class="language-scala">var a, b
init ≜ a = I ∧ b = I
alice ≜ a' = W if a = I
    ∨ a' = C if a = W ∧ b = I
    ∨ a' = I if a = C

bob ≜ b' = W if b = I
    ∨ b' = C if b = W ∧ a = I
    ∨ b' = I if b = C

spec = init ∧ ☐(alice ∨ bob)
</code></pre>
<p><strong>Interesting side-note:</strong> As long as we are not concerned by specification refinement it is OK to disable stuttering: completely for safety verification and partially for liveness (stutter only on deadlock).
With stuttering disabled the one-bit clock specification will disallow the behaviors where the clock never ticks.</p>
<pre><code>0 → 0 → 0 → 0 → 0 → ...
1 → 1 → 1 → 1 → 1 → ...
</code></pre>
<h3 id="exercises"><a class="header" href="#exercises">Exercises</a></h3>
<p><strong>Exercise 1:</strong> Encode the previous specifications using the STR (like the ExampleSTR).</p>
<p><strong>Exercise 2:</strong> Connect the STR2RG, ParentTracer and Reachability algorithm to implement a simple predicate verification setup.</p>
<p><strong>Exercise 3:</strong> Use the verification setup to verify the mutual exclusion property <code>[]! (a = C ∧ b = C)</code> on the following specification (<code>Simple Alice-Bob</code>):</p>
<pre><code class="language-scala">var a, b
init ≜ a = I ∧ b = I
alice ≜ a' = C if a = I
    ∨ a' = I if a = C

bob ≜ b' = C if b = I
    ∨ b' = I if b = C

spec = init ∧ ☐(alice ∨ bob)
</code></pre>
<p><strong>Exercise 4:</strong> Use the verification setup to verify that mutual exclusion property on the <code>Flag Alice-Bob</code> specification.</p>
<p><strong>Exercise 5:</strong> Verify that <code>Simple Alice-Bob</code> and <code>Flag Alice-Bob</code> are deadlock-free. How can we encode the deadlock-freedom property?</p>
<hr>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-simple-python-edsl-for-piecewise-relations"><a class="header" href="#a-simple-python-edsl-for-piecewise-relations">A Simple Python eDSL for Piecewise Relations</a></h1>
<p><img src="/assets/img/z2mc/overview_04.png" alt="Progress Overview" />{: width=&quot;400&quot; style=&quot;display:block; margin-left:auto; margin-right:auto&quot;}</p>
<p>Implementing the STR directly works, but looking at our last specifications using the made-up language we see that there is a certain syntactical pollution. To address this issue in this chapter we will create a simple <strong>e</strong>mbedded <strong>D</strong>omain-<strong>S</strong>pecific <strong>L</strong>anguage (eDSL) in Python.</p>
<p><strong>Note:</strong> Creating an external DSL for our specification language is outside the scope of this work. The interested reader is nevertheless encouraged to try. Such a reader is encouraged to study the TLA+ syntax to find other (rather inspired) operators, which can further simplify the syntax. Readers keen on the graphical syntax could study UML statecharts in conjunction with the AnimUML specification and verification environment to get another more graphical perspective.</p>
<p>Our eDSL will be named <strong>Soup</strong>, because it will encode the specifications as a <code>soup</code> of <code>pieces</code> necessary to encode the piecewise relations.</p>
<p>The first ingredient, which will encode the valuation of the variables used in a specification is identical to the <code>Configuration</code> concept that we have used for generalizing the <code>Vertex</code> types in the graph abstraction.</p>
<p>For the one-bit clock example we will have:</p>
<pre><code class="language-python">class OneBitClockConfig:
    def __init__(self, value):
        self.clock = value

    def __hash__(self):
        return hash(self.clock)

    def __eq__(self, other):
        if not isinstance(other, OneBitClockConfig):
            return False
        return self.clock == other.clock

    def __repr__(self):
        return f'clock={self.clock}'
</code></pre>
<p>The <code>initialization</code> part of the specification can be decomposed around the disjunctions. Each term in the disjunction will become a unique configuration. Moreover, each such term is required to initialize all the variables. Thus the <code>initialization</code> of the one-bit clock will be defined as follows:</p>
<pre><code class="language-python">init = [OneBitClockConfig(0), OneBitClockConfig(1)]
</code></pre>
<p>Each piece of the relation will be encoded as two lambdas encapsulated in a <code>LambdaPiece</code> object, defined as follows:</p>
<pre><code class="language-python">class LambdaPiece:
    def __init__(self, name='', guard, generator):
        self.name = name
        self.guard = guard
        self.generator = generator

    def __eq__(self, other):
        if not isinstance(other, LambdaPiece):
            return False
        return self.name == other.name and self.guard == other.guard and self.generator == other.generator
</code></pre>
<p>For the one-bit clock specification, we get:</p>
<pre><code class="language-python">toOne  = LambdaPiece('toOne',  lambda c: OneBitClockConfig(1), lambda c: c.clock == 0)
toZero = LambdaPiece('toZero', lambda c: OneBitClockConfig(0), lambda c: c.clock == 1 )
</code></pre>
<p>The specification is captured in a <code>Soup</code> instance, defined as follows:</p>
<pre><code class="language-python">class Soup:
    def __init__(self, initial=[], pieces=[]):
        self.initial = initial
        self.pieces = pieces

    def add(self, name, guard, generator):
        self.extend(LambdaPiece(name, guard, generator))

    def extend(self, beh):
        if isinstance(beh, LambdaPiece):
            self.pieces.append(beh)
        else:
            self.pieces.extend(beh)
</code></pre>
<p>For the one-bit clock specification, the soup is:</p>
<pre><code class="language-python">one_bit_clock_spec = Soup(init, [toOne, toZero])
</code></pre>
<p>To interpret the soup as a piecewise relation, the next step is to implement the semantics as follows:</p>
<pre><code class="language-python">class RootedPiecewiseRelationSemantics(SemanticTransitionRelation):
    def __init__(self, soup):
        self.soup = soup

    def roots(self):
        return self.soup.initial

    def enabled(self, configuration):
        return list(filter(lambda ga: ga.guard(configuration), self.soup.pieces))

    def execute(self, action, configuration):
        target = copy.deepcopy(configuration)
        the_output = action.generator(target)
        return the_output
</code></pre>
<p>Note that in the implementation of the <code>execute</code> function we perform a <strong>deepcopy</strong>. Is this necessary? Knowing that the generator lambda produces a new configuration each time. Explain and give an example where this is necessary.</p>
<p>By the way, the one-bit specification can be even shorter:</p>
<pre><code class="language-python">one_bit_clock_spec = Soup(
    [0, 1],
    [
        LambdaPiece('toOne',  lambda c: 1, lambda c: c == 0),
        LambdaPiece('toZero', lambda c: 0, lambda c: c == 1)
    ]
)
</code></pre>
<p>Why does it work? Can you explain why we do not <em>strictly</em> need a <code>Configuration</code> object in this case?</p>
<p>It can be rather similar to the spec in the previous chapter if written as follows:</p>
<pre><code class="language-python">init = [0, 1]
tick = [
        LambdaPiece(lambda c: 1, lambda c: c == 0),
        LambdaPiece(lambda c: 0, lambda c: c == 1)]
spec = Soup(init, tick)
</code></pre>
<h3 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h3>
<p><strong>Exercise 1:</strong> Encode the specifications from the previous chapter using the Soup language.
<strong>Exercise 2:</strong> Create a predicate verification tool for the Soup language.</p>
<p><strong>Exercise 3:</strong> Verify the mutual exclusion property on the Soup-based <code>Simple Alice-Bob</code> specification.</p>
<p><strong>Exercise 4:</strong> Verify the mutual exclusion property on the Soup-based <code>Flag Alice-Bob</code> specification.</p>
<p><strong>Exercise 5:</strong> Verify that <code>Simple Alice-Bob</code> and <code>Flag Alice-Bob</code> are deadlock-free.</p>
<p><strong>Make sure that the results match the ones obtained in the previous chapter</strong>. If they don't match find and fix the bugs.</p>
<p><strong>Exercise 6:</strong> Encode the Hanoi problem using the Soup language and use the Soup predicate verifier to find the solution.</p>
<p><strong>Exercise 7:</strong> <strong>TODO:</strong> German traffic light and history management.</p>
<hr>
<div style="break-before: page; page-break-before: always;"></div><h1 id="more-expressive-properties-through-dependent-semantics"><a class="header" href="#more-expressive-properties-through-dependent-semantics">More Expressive Properties Through Dependent Semantics</a></h1>
<p><img src="/assets/img/z2mc/overview_05.png" alt="Progress Overview" />{: width=&quot;400&quot; style=&quot;display:block; margin-left:auto; margin-right:auto&quot;}</p>
<p>Until now our verification tasks were limited to predicate verification. To go further we need to extend the expressivity of the &quot;property&quot; language, which was restricted to simple state predicates. To achieve this we will first extend our semantical framework to allow the creation of dependencies between different semantics. The discussion in this chapter is based on the Soup language, which is extended to allow the design of dependent specifications.</p>
<p>One case where dependent semantics can came in handy is specifying the behaviour of a minute clock based on the ticks of the one-bit clock. The minute variable should be incremented on the rising edge of the one-bit clock.</p>
<pre><code class="language-scala">var minutes
init ≜ minutes ∈ {1..60}             -- note the non-deterministic assignement
tick ≜ minutes' = (minutes + 1) % 60 + 1 if clock = 0 ∧ clock' = 1
spec ≜ init ∧ ☐(tick ∨ minutes' = minutes)
</code></pre>
<p><img src="/assets/img/z2mc/dependent_trace_step.png" alt="step-dependent behavior" />{: style=&quot;display:block; margin-left:auto; margin-right:auto&quot;}</p>
<p>Another example is the hour clock based on the minute clock.</p>
<pre><code class="language-scala">var hour
init ≜ hour ∈ {1..12}             -- note the non-deterministic assignement
tick ≜ hour' = (hour + 1) % 12 + 1 if minutes = 60
spec ≜ init ∧ ☐(tick ∨ hour' = hour)
</code></pre>
<p>If we are looking at these previous specification they seem incomplete. The minute clock specification defines its behaviour relatively to another behavior, from which it can extract a notion of <code>clock</code>. The name <code>clock</code> is used in the minute-clock but its behaviour is never defined.</p>
<p><img src="/assets/img/z2mc/dependent_semantics_example.png" alt="dependent semantics example" />{: style=&quot;display:block; margin-left:auto; margin-right:auto&quot;}</p>
<p>We define a dependent semantics as a semantics that requires some additional input (of type <code>I</code>), besides the current configuration (of type <code>C</code>), to:</p>
<ol>
<li>decide what is the set of enabled actions. If The <code>actions</code> function signature becomes <code>actions: I → C → set A</code>.</li>
<li>compute the target configuration set, during the execution of an action. The <code>execute</code> signature becomes <code>execute: A → I → C → set C</code>.</li>
</ol>
<p>Now that we have an input-dependent semantics, we can define an output producing semantics to improve the symmetry of our design. Such a semantics should produce an output during the execution of a step, in such a way that is possible to connect it to the an input-dependent semantics. To achieve this, we extend the signature of the <code>execute</code> function: <code>execute: A → I → C → set (O × C)</code>. During the execution of an action an output <code>O</code> is produced, besides the new configuration.</p>
<p>With these two ideas our semantically framework evolves, to something very similar to Mealy abstract machines. The execution step is dependent on the current configuration, and the input.  Action execution effectivelly computes the next comfiguration and the output. Thus a step in the semantics state-space becomes:</p>
<p><img src="/assets/img/z2mc/io_step.png" alt="io semantics step" />{: style=&quot;display:block; margin-left:auto; margin-right:auto&quot;}</p>
<pre><code class="language-python">class RootedPiecewiseRelationDependentSemantics:

    def __init__(self, soup):
        self.soup = soup

    def roots(self):
        return self.soup.initial

    def enabled(self, input, configuration):
        return list(filter(lambda ga: ga.guard(input, configuration), self.soup.pieces))

    def execute(self, action, input, configuration):
        target = copy.deepcopy(configuration)
        the_output = action.generator(input, target)
        return the_output
</code></pre>
<pre><code class="language-python">class ToStepOutputSemantics:

    def __init__(self, subject):
        self.subject = subject

    def roots(self):
        return self.subject.initial

    def enabled(self, configuration):
        return self.subject.enabled

    def execute(self, action, configuration):
        the_targets = self.subject.execute(action, configuration)
        
        return list(map(lambda t: ((configuration, action, t), t), the_targets))
</code></pre>
<hr>
<div style="break-before: page; page-break-before: always;"></div><h1 id="computing-the-intersection-between-the-system-and-the-property"><a class="header" href="#computing-the-intersection-between-the-system-and-the-property">Computing the Intersection Between the System and the Property</a></h1>
<p><img src="/assets/img/z2mc/overview_06.png" alt="Progress Overview" />{: width=&quot;400&quot; style=&quot;display:block; margin-left:auto; margin-right:auto&quot;}</p>
<h2 id="safety-properties-looking-into-the-past"><a class="header" href="#safety-properties-looking-into-the-past">Safety Properties: Looking into the Past</a></h2>
<h3 id="theoretical-approach"><a class="header" href="#theoretical-approach">Theoretical approach</a></h3>
<ol>
<li>Collect the atomic propositions</li>
<li>Compute the Kripke structure of the state-space</li>
<li>Convert the Kripke structure to NFA.</li>
<li>Compose the system NFA with the property NFA</li>
</ol>
<h3 id="let-the-property-compute-the-kripke-interpretation"><a class="header" href="#let-the-property-compute-the-kripke-interpretation">Let the property compute the Kripke interpretation</a></h3>
<ol>
<li>Convert the state-space to a NFA</li>
<li>Compose the system NFA with the property NFA</li>
</ol>
<h3 id="dynamic-composition-of-the-system-with-the-property"><a class="header" href="#dynamic-composition-of-the-system-with-the-property">Dynamic Composition of the System with the Property</a></h3>
<ol>
<li>Dynamically obtain an NFA interpretation of the system during the composition.</li>
</ol>
<pre><code class="language-python">class ConfigurationSynchronousProduct(SemanticTransitionRelation):
    def __init__(self, lhs, rhs):
        self.lhs = lhs
        self.rhs = rhs

    def initial(self):
        return list(map(lambda c: (None, c), self.rhs.initial()))

    def actions(self, source):
        synchronous_actions = []
        lhs_source, rhs_source = source
        if source[0] is None:
            for target in self.lhs.initial():
                self.get_synchronous_actions(target, rhs_source, synchronous_actions)
            return synchronous_actions
        # get all lhs actions
        lhs_actions = self.lhs.actions(lhs_source)
        number_of_actions = len(lhs_actions)
        for lhs_a in lhs_actions:
            _, target = self.lhs.execute(lhs_a, lhs_source)
            if target is None:
                number_of_actions -= 1
            self.get_synchronous_actions(target, rhs_source, synchronous_actions)

        # if number_of_actions == 0:
        #     self.get_synchronous_actions(kripke_source, buchi_source, synchronous_actions)
        return synchronous_actions

    def get_synchronous_actions(self, lhs_config, rhs_config, io_synchronous_actions):
        rhs_actions = self.rhs.actions(lhs_config, rhs_config)
        io_synchronous_actions.extend(map(lambda ra: (lhs_config, ra), rhs_actions))

    def execute(self, action, configuration):
        lhs_target, rhs_action = action
        _, rhs_source = configuration
        return kripke_target, self.rhs.execute(rhs_action, lhs_target, rhs_source)
</code></pre>
<h3 id="step-predicates-looking-at-execution-steps"><a class="header" href="#step-predicates-looking-at-execution-steps">Step Predicates: Looking at execution steps</a></h3>
<p>Expressing conditions on execution steps expands the possibilities for debugging. First of all, the step breakpoints allow us to reason about the action between the configurations. In their simplest form, they can allow stopping the execution when a named action is reached, <code>|action(&quot;toOne&quot;)|</code>.</p>
<p>Furthermore, the step breakpoints allow reasoning on the delta changes between two consecutive configurations of a behavior (before and after an action). For instance, this will allow us to detect the rising edge of the one-bit clock, <code>|clock=0 &amp;&amp; clock'=1|</code>.</p>
<pre><code class="language-python">class StepSynchronousProduct(SemanticTransitionRelation):
    def __init__(self, lhs, rhs):
        self.lhs = lhs
        self.rhs = rhs

    def initial(self):
        initial_configurations = []
        for lc in self.lhs.initial():
            for rc in self.rhs.initial():
                initial_configurations.append((lc, rc))
        return initial_configurations

    def actions(self, configuration):
        synchronous_actions = []
        # get all lhs actions
        lhs_actions = self.lhs.actions(configuration[0])
        number_of_actions = len(lhs_actions)
        for lhs_a in lhs_actions:
            step, target = self.lhs.execute(lhs_a, configuration[0])
            if target is None:
                number_of_actions -= 1
            rhs_actions = self.rhs.actions(step, configuration[1])
            synchronous_actions.extend(map(
                    lambda ra: (step, ra),
                    rhs_actions
                ))

        if number_of_actions == 0:
            step = (configuration[0], StutteringAction.instance(), configuration[0])
            rhs_actions = self.rhs.actions(step, configuration[1])
            synchronous_actions.extend(map(
                lambda ra: (step, ra),
                rhs_actions
            ))
        return synchronous_actions

    def execute(self, action, configuration):
        step = action[0]
        target = self.rhs.execute(action[1], step, configuration[1])
        return step[2], target
</code></pre>
<hr>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nested-reachability-for-liveness-verification"><a class="header" href="#nested-reachability-for-liveness-verification">Nested Reachability for Liveness Verification</a></h1>
<p><img src="/assets/img/z2mc/overview_07.png" alt="Progress Overview" />{: width=&quot;400&quot; style=&quot;display:block; margin-left:auto; margin-right:auto&quot;}</p>
<h2 id="liveness-properties-thinking-about-the-future"><a class="header" href="#liveness-properties-thinking-about-the-future">Liveness Properties: Thinking about the Future</a></h2>
<hr>
<h2 id="improving-liveness-verification-performance"><a class="header" href="#improving-liveness-verification-performance">Improving Liveness Verification Performance</a></h2>
<p><img src="/assets/img/z2mc/overview_08.png" alt="Progress Overview" />{: width=&quot;400&quot; style=&quot;display:block; margin-left:auto; margin-right:auto&quot;}</p>
<p>Implement the following state-of-the-art algorithms.</p>
<p><img src="/assets/img/z2mc/buchi_algo_hierarchy.svg" alt="Buchi Algorithms" /></p>
<hr>
<div style="break-before: page; page-break-before: always;"></div><h1 id="seeing-the-algorithms-as-dependent-specifications"><a class="header" href="#seeing-the-algorithms-as-dependent-specifications">Seeing the Algorithms as Dependent Specifications</a></h1>
<p><img src="/assets/img/z2mc/overview_09.png" alt="Progress Overview" />{: width=&quot;400&quot; style=&quot;display:block; margin-left:auto; margin-right:auto&quot;}</p>
<hr><div style="break-before: page; page-break-before: always;"></div><h1 id="underapproximations"><a class="header" href="#underapproximations">Underapproximations</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
