<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://teodorov.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://teodorov.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-10-21T09:28:41+00:00</updated><id>https://teodorov.github.io/feed.xml</id><title type="html">blank</title><subtitle>Cip&apos;s homepage </subtitle><entry><title type="html">G∀min∃ Semantic Language Interface</title><link href="https://teodorov.github.io/blog/2024/gamine_sli/" rel="alternate" type="text/html" title="G∀min∃ Semantic Language Interface"/><published>2024-10-20T00:00:00+00:00</published><updated>2024-10-20T00:00:00+00:00</updated><id>https://teodorov.github.io/blog/2024/gamine_sli</id><content type="html" xml:base="https://teodorov.github.io/blog/2024/gamine_sli/"><![CDATA[<style>body{text-align:justify}</style> <p>The G∀min∃ Semantic Language Interface (SLI) is a framework designed to bridge the gap between executable specifications and behavior analysis tools. It captures the operational semantics of programming languages, called subject language in the following. Two key particularities of the SLI are:</p> <ul> <li><strong>exposes all non-determinism</strong> that might be present in the subject language;</li> <li>requires the definition of a <strong>step evaluation</strong> function, used to query the execution steps based on a <em>diagnosis language</em>.</li> </ul> <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="nc">SLI</span> <span class="o">≜</span>
    <span class="nf">semantics</span><span class="o">(</span><span class="n">C</span> <span class="n">A</span><span class="o">)</span> <span class="o">≜</span>
        <span class="n">initial</span><span class="k">:</span> <span class="kt">set</span> <span class="kt">C</span>              <span class="c1">//the set of initial configurations</span>
        <span class="n">actions</span><span class="k">:</span> <span class="kt">C</span> <span class="kt">→</span> <span class="kt">set</span> <span class="kt">A</span>          <span class="c1">//the set of actions executable from a configuration</span>
        <span class="n">execute</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">→</span> <span class="kt">C</span> <span class="kt">→</span> <span class="kt">set</span> <span class="kt">C</span>      <span class="c1">//execute one action in one configuration</span>
    <span class="n">evaluate</span><span class="k">:</span> <span class="kt">E</span> <span class="kt">→</span> <span class="o">(</span><span class="kt">C</span> <span class="kt">x</span> <span class="kt">A</span> <span class="kt">x</span> <span class="kt">C</span><span class="o">)</span> <span class="kt">→</span> <span class="kt">V</span>   <span class="c1">// questions on steps</span>
    <span class="n">reduce</span><span class="k">:</span> <span class="kt">R</span> <span class="kt">→</span> <span class="kt">C</span> <span class="kt">→</span> <span class="kt">⍺</span>               <span class="c1">// configuration reductions</span>
    <span class="nf">π</span> <span class="o">(</span><span class="n">C</span> <span class="n">A</span> <span class="n">V</span> <span class="o">⍺</span> <span class="n">T</span><span class="o">)</span> <span class="o">≜</span> <span class="o">⋯</span>               <span class="c1">// projections of the semantical entities</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>Let’s explore the key components of the SLI as defined:</p> <h2 id="semantics-definition">Semantics Definition</h2> <p>At the heart of the SLI lies the subject language semantics, which are captured through 3 functions:</p> <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="nf">semantics</span> <span class="o">(</span><span class="n">C</span> <span class="n">A</span><span class="o">)</span> <span class="o">≜</span>
    <span class="n">initial</span><span class="k">:</span> <span class="kt">set</span> <span class="kt">C</span>
    <span class="n">actions</span><span class="k">:</span> <span class="kt">C</span> <span class="kt">→</span> <span class="kt">set</span> <span class="kt">A</span>
    <span class="n">execute</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">→</span> <span class="kt">C</span> <span class="kt">→</span> <span class="kt">set</span> <span class="kt">C</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p>where:</p> <ul> <li><code class="language-plaintext highlighter-rouge">C</code>: is a type capturing the semantic <em>configurations</em> (the execution state) of the subject language;</li> <li><code class="language-plaintext highlighter-rouge">A</code>: is an <em>action</em> type, that classifies all the transition rules of the underlying semantics. In general, an action can be thought as a function from configurations to sets of configurations <code class="language-plaintext highlighter-rouge">action: C → set C</code>;</li> <li><code class="language-plaintext highlighter-rouge">initial: set C</code>: This function defines a set of initial configurations from which the system can start. Allowing multiple initial configurations, allow to capture the <em>initial non-determinism</em> that might be present in the subject language. If the subject language does not have <em>initial non-determinism</em> one can always return a singleton.</li> <li><code class="language-plaintext highlighter-rouge">actions: C → set A</code>: This mapping relates each configuration to a set of executable actions, the set of functions <code class="language-plaintext highlighter-rouge">C → set C</code> that can be executed in a configuration <code class="language-plaintext highlighter-rouge">c ∈ C</code>. Allowing multiple actions to be enabled in a configuration, allows capturing the potential <em>action non-determinism</em> of the subject language. This is typically the case for concurrent languages, where two threads (actors, state-machines) have enabled actions in a given configuration (execution state). A singleton can be returned, when only one action is available;</li> <li><code class="language-plaintext highlighter-rouge">execute: A → C → set C</code>: This functions executes an action <code class="language-plaintext highlighter-rouge">a ∈ A</code> in a specific configuration to obtain the set of resulting configurations. <em>Execution non-determinism</em> is captured by the production of multiple configurations during the action execution. This typically arises when the subject language semantics choses to allow non-deterministic actions (rules). While in principle it is possible to flatten <em>execution non-determinism</em> to <em>action non-determinism</em>, it is sometimes advantageous for a subject language semantics to hide some low-level operational steps in the action functions.</li> </ul> <h2 id="step-evaluation">Step Evaluation</h2> <p>The execution of a subject language semantics, captured through the SLI semantic functions, gives rise to <strong>execution steps</strong>. An <strong>execution step</strong> is a triplet (c₁, a, c₂) from the ternary relation <code class="language-plaintext highlighter-rouge">Steps ⊆ (C x A x C)</code> of execution steps allowed by the semantics. The steps are usually not explicitly captured by a specification (the exception being raw graphs, in <a href="https://en.wikipedia.org/wiki/Trivial_Graph_Format">TGF</a> format for instance), but they arise during the execution of the semantics.</p> <p>The SLI proposes to use an <code class="language-plaintext highlighter-rouge">evaluate: E → (C x A x C) → V</code> function on <em>execution steps</em>, to isolate the language specific encoding of the configurations and actions from the tools needing to reason about the execution of a semantics. This function hides the implementation details by offering the means to answer queries on an <em>execution step</em> through subject-language specific expressions, in a <strong>diagnosis language</strong>. The <code class="language-plaintext highlighter-rouge">evaluate</code> function evaluates an expression e ∈ E in the context of an <em>execution step</em> (c₁, a, c₂) to produce a value v ∈ V, where <code class="language-plaintext highlighter-rouge">V</code> is a type classifying the set of values used in the subject-language semantics.</p> <p>Note, however, that the values from <code class="language-plaintext highlighter-rouge">V</code> are specific to the subject-language semantics, and that usage-specific transformations might be needed to convert these values to the domain of values needed by the caller of the <code class="language-plaintext highlighter-rouge">evaluate</code> function.</p> <p>The reader, can think of this evaluation function as an extension of an typical <code class="language-plaintext highlighter-rouge">eval</code> function, pioneered by LISP and present in a number of programming languages today. This extension of the typical <code class="language-plaintext highlighter-rouge">eval</code> is necessary to allow richer <em>diagnosis queries</em> without the need to flatten the state-space to a lower-level <a href="https://en.wikipedia.org/wiki/Kripke_structure_(model_checking)">Kripke structure</a>, which would push the actions, and the valuation of (source, target) predicates from the edges to the target configuration view.</p> <h2 id="reduction">Reduction</h2> <p>The <code class="language-plaintext highlighter-rouge">reduce: R → C → ⍺</code> function, of the G∀min∃ SLI, simplifies or collapses configurations into a more abstract representation, denoted by ⍺. This capability aids in analyzing the behavior of the system by simplifying the state-representation. This function allows implementing multiple state-space reduction strategies ranging from precise abstractions like symmetry reduction, and predicate abstraction to brutal under-approximations like bitstate hashing and hashcompaction.</p> <h2 id="projections-of-semantical-entities">Projections of Semantical Entities</h2> <p>Lastly, the SLI provides a way to project various semantical entities:</p> <p><code class="language-plaintext highlighter-rouge">π (C A V ⍺ T)</code>: This set of functions represent the projections of semantical entities, including configurations (<code class="language-plaintext highlighter-rouge">C</code>), actions (<code class="language-plaintext highlighter-rouge">A</code>), evaluation results (<code class="language-plaintext highlighter-rouge">V</code>), reduced forms (<code class="language-plaintext highlighter-rouge">⍺</code>). These projections allow users map the language specific values to a target value domain <code class="language-plaintext highlighter-rouge">T</code> either for user consumption (through pretty-printing) or for further processing in the client context (through data transformations).</p> <h2 id="conclusion">Conclusion</h2> <p>The G∀min∃ Semantic Language Interface (SLI) offers a robust framework for modeling operational semantics, making it a powerful tool for analyzing system behavior. By capturing non-determinism and providing structured methods for evaluation and reduction, the SLI enhances the process of formal verification, ultimately contributing to the development of reliable and well-designed systems.</p> <p>This interface can be viewed as an operational implementation of the more theoretical approach presented in Omnisemantics <a href="#1">[1]</a>. In contrast to this approach, the SLI requires the existence of computable interpretation of the predicates that relate each state to a set of target states. This may seem like a very strong limitation compared to Omnisemantics, but it reflects the constraints imposed on language semantics by execution environments. Another manifestation of this constraint can be found in the context of TLA <a href="#2">[2]</a>, which also imposes the existence of a computable interpretation of predicates to enable the execution, debugging, and model checking of specifications <a href="#3">[3]</a>.</p> <h1 id="references">References</h1> <p><a id="1">[1]</a> Arthur Charguéraud, Adam Chlipala, Andres Erbsen, and Samuel Gruetter. 2023. Omnisemantics: Smooth Handling of Nondeterminism. ACM Trans. Program. Lang. Syst. 45, 1, Article 5 (March 2023), 43 pages. https://doi.org/10.1145/3579834</p> <p><a id="1">[2]</a> Leslie Lamport. 1994. The temporal logic of actions. ACM Trans. Program. Lang. Syst. 16, 3 (May 1994), 872–923. https://doi.org/10.1145/177492.177726</p> <p><a id="1">[3]</a> Yuan Yu, Panagiotis Manolios, and Leslie Lamport. 1999. Model Checking TLA+ Specifications. In Proceedings of the 10th IFIP WG 10.5 Advanced Research Working Conference on Correct Hardware Design and Verification Methods (CHARME ‘99). Springer-Verlag, Berlin, Heidelberg, 54–66.</p>]]></content><author><name></name></author><category term="research"/><category term="semantics"/><category term="operational semantics"/><category term="semantics"/><category term="executable models"/><summary type="html"><![CDATA[a brief introduction to the G∀min∃ Semantic Language Interface]]></summary></entry><entry><title type="html">Multiverse Debugging</title><link href="https://teodorov.github.io/blog/2024/multiverse_debugging/" rel="alternate" type="text/html" title="Multiverse Debugging"/><published>2024-10-10T00:00:00+00:00</published><updated>2024-10-10T00:00:00+00:00</updated><id>https://teodorov.github.io/blog/2024/multiverse_debugging</id><content type="html" xml:base="https://teodorov.github.io/blog/2024/multiverse_debugging/"><![CDATA[<style>body{text-align:justify}</style> <p><strong>Multiverse debugging</strong> offers a powerful toolset for addressing the inherent complexity and non-determinism in concurrent systems. It opens new possibilities for developers and researchers to understand, analyze, optimize, and improve system reliability and performance.</p> <p>The concept of the <em>multiverse</em>, though controversial in philosophy <a href="#1">[1]</a> and physics <a href="#2">[2]</a>, has gained traction in psychology <a href="#3">[3]</a> and neurology <a href="#4">[4]</a>, where multiverse analysis addresses the researcher’s degrees of freedom issue <a href="#5">[5]</a>. In mathematics, the multiverse framework is seen in foundational interpretations of set theory <a href="#6">[6]</a>. In engineering, Leslie Lamport’s Temporal Logic of Actions (TLA) <a href="#7">[7]</a> conceptualizes system specifications within an implicit underlying universe. This framework complements Edward Lee’s view on engineering models <a href="#8">[8]</a>, where engineers are seen as creators of their design universes.</p> <p>In computer science, the multiverse concept was first introduced in <a href="#10">[10]</a> to address challenges in debugging concurrent actor programs. <strong>Multiverse debugging</strong> proposes to explore all potential program behaviors, paralleling modal temporal logics and Kripke’s possible worlds interpretations <a href="#9">[9]</a>. The idea of <strong>multiverse debugging</strong> was extended to the formal analysis of behavioral specifications <a href="#11">[11]</a><a href="#12">[12]</a><a href="#13">[13]</a>, where it served as a cohesive metaphor for integrating debugging and model-checking <a href="#11">[11]</a>. This integration enhances breakpoint expressivity <a href="#11">[11]</a> and facilitates interactive analysis of complex systems <a href="#13">[13]</a>. Early scalability concerns <a href="#10">[10]</a> were mitigated by M. Pasquier et al. in <a href="#12">[12]</a>, who demonstrated that <strong>multiverse debugging</strong> could be optimized through the integration of a variety of under-approximation techniques <a href="#14">[14]</a>.</p> <h2 id="references">References</h2> <p><a id="1">[1]</a> S. Friederich, Multiverse Theories: A Philosophical Perspective. Cambridge: Cambridge University Press, 2021.</p> <p><a id="2">[2]</a> John F. Donoghue. The multiverse and particle physics. Annual Review of Nuclear and Particle Science, 66(Volume 66, 2016):1–21, 2016.</p> <p><a id="3">[3]</a> Steegen, S., Tuerlinckx, F., Gelman, A., &amp; Vanpaemel, W. (2016). Increasing Transparency Through a Multiverse Analysis. Perspectives on Psychological Science, 11(5), 702-712. https://doi.org/10.1177/1745691616658637</p> <p><a id="4">[4]</a> Clayson, Peter E. (2024-03-01). “Beyond single paradigms, pipelines, and outcomes: Embracing multiverse analyses in psychophysiology”. International Journal of Psychophysiology. 197: 112311. doi:10.1016/j.ijpsycho.2024.112311. ISSN 0167-8760</p> <p><a id="5">[5]</a> Wicherts, Jelte M.; Veldkamp, Coosje L. S.; Augusteijn, Hilde E. M.; Bakker, Marjan; van Aert, Robbie C. M.; van Assen, Marcel A. L. M. (2016). “Degrees of Freedom in Planning, Running, Analyzing, and Reporting Psychological Studies: A Checklist to Avoid p-Hacking”. Frontiers in Psychology. 7: 1832. doi:10.3389/fpsyg.2016.01832. PMC 5122713. PMID 27933012.</p> <p><a id="6">[6]</a> D. Hamkins, “The Set-theoretic Multiverse,” The Review of Symbolic Logic, vol. 5, no. 3, pp. 416–449, 2012. doi:10.1017/S1755020311000359</p> <p><a id="7">[7]</a> Leslie Lamport. 1994. The temporal logic of actions. ACM Trans. Program. Lang. Syst. 16, 3 (May 1994), 872–923. https://doi.org/10.1145/177492.177726</p> <p><a id="8">[8]</a> Edward A. Lee. 2018. Modeling in engineering and science. Commun. ACM 62, 1 (January 2019), 35–36. https://doi.org/10.1145/3231590.</p> <p><a id="9">[9]</a> Raymond D. Bradley, Norman Swartz, Possible Worlds – An Introduction to Logic and its Philosophy, Hackett Publishing (1979).</p> <p><a id="10">[10]</a> Carmen Torres Lopez, Robbert Gurdeep Singh, Stefan Marr, Elisa Gonzalez Boix, and Christophe Scholliers. Multiverse Debugging: Non-Deterministic Debugging for Non-Deterministic Programs (Brave New Idea Paper). In 33rd European Conference on Object-Oriented Programming (ECOOP 2019). Leibniz International Proceedings in Informatics (LIPIcs), Volume 134, pp. 27:1-27:30, Schloss Dagstuhl – Leibniz-Zentrum für Informatik (2019) https://doi.org/10.4230/LIPIcs.ECOOP.2019.27</p> <p><a id="11">[11]</a> Matthias Pasquier, <strong>Ciprian Teodorov</strong>, Frédéric Jouault , Matthias Brun , Luka Le Roux. Temporal Breakpoints for Multiverse Debugging. Software Language Engineering 2023, Oct 2023, Lisbonne, Portugal.</p> <p><a id="12">[12]</a> Matthias Pasquier, <strong>Ciprian Teodorov</strong>, Frédéric Jouault , Matthias Brun , Luka Le Roux. Practical multiverse debugging through user-defined reductions. MODELS ‘22: ACM/IEEE 25th International Conference on Model Driven Engineering Languages and Systems, Oct 2022, Montreal Quebec Canada, Canada. pp.87-97, ⟨10.1145/3550355.3552447⟩.</p> <p><a id="13">[13]</a> Matthias Pasquier, <strong>Ciprian Teodorov</strong>, Frédéric Jouault , Matthias Brun , Loïc Lagadec. Debugging Paxos in the UML Multiverse. MODELS-C/MoDeVVa, Oct 2023, Västerås, Sweden.</p> <p><a id="14">[14]</a> Radek Pelanek. Reduction and Abstraction Techniques for Model Checking. Ph.D. Thesis, Masaryk University, 2006.</p>]]></content><author><name></name></author><category term="research"/><category term="debugging"/><summary type="html"><![CDATA[a brief introduction to multiverse debugging]]></summary></entry></feed>