<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://teodorov.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://teodorov.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-12-06T22:49:36+00:00</updated><id>https://teodorov.github.io/feed.xml</id><title type="html">blank</title><subtitle>The homepage of Ciprian Teodorov
</subtitle><entry><title type="html">A Typeclass for Simple FIFO Queues</title><link href="https://teodorov.github.io/blog/2022/lean-queue/" rel="alternate" type="text/html" title="A Typeclass for Simple FIFO Queues" /><published>2022-01-25T20:00:00+00:00</published><updated>2022-01-25T20:00:00+00:00</updated><id>https://teodorov.github.io/blog/2022/lean-queue</id><content type="html" xml:base="https://teodorov.github.io/blog/2022/lean-queue/"><![CDATA[<p>In this post I want to cover a typeclass definition for a <em>simple queue</em>.
A <em>simple queue</em> is an unbounded data structure that maintains a collection of elements of an arbitrary type <code class="language-plaintext highlighter-rouge">α : Type u</code>) in a sequence. 
From a queue we can only retrieve the element at the <em>front</em> and verify it is <em>empty</em>.
The queue can be modified either by adding elements at the tail or by removing elements at the <em>front</em>.</p>

<p>The list of operations is:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">empty: Q α</code>              – create an empty queue</li>
  <li><code class="language-plaintext highlighter-rouge">is_empty: Q α → bool</code>    – check if a queue is empty</li>
  <li><code class="language-plaintext highlighter-rouge">front: Q α → option α</code>   – retrieve/peek the front element</li>
  <li><code class="language-plaintext highlighter-rouge">enqueue: α → Q α → Q α</code>  – add an element at the end of the queue</li>
  <li><code class="language-plaintext highlighter-rouge">dequeue: Q α → Q α</code>      – remove the element at the front</li>
</ul>

<p>An implementation of these operations is correct with respect of the simple Queue if the following equations are true:</p>

<p>An empty queue is_empty</p>

<p>[e₁] <code class="language-plaintext highlighter-rouge">is_empty empty = tt</code></p>

<p>A non-empty queue ¬is_empty</p>

<p>[e₂] <code class="language-plaintext highlighter-rouge">∀ x Q₀, is_empty (enqueue x Q₀) = ff</code></p>

<p>An empty queue doesn’t have a front</p>

<p>[e₃] <code class="language-plaintext highlighter-rouge">front empty = none</code></p>

<p>A non-empty queue has a front</p>

<p>[e₄] <code class="language-plaintext highlighter-rouge">∀ x Q₀,  is_empty Q₀ → front (enqueue x Q₀) = some x</code></p>

<p>Front is not changed by an insertion in a non-empty queue</p>

<p>[e₅] <code class="language-plaintext highlighter-rouge">∀ x Q₀, ¬is_empty Q₀ → front (enqueue x Q₀) = front Q₀</code></p>

<p>Dequeue from an empty queue has no effect</p>

<p>[e₆] <code class="language-plaintext highlighter-rouge">dequeue empty = empty</code></p>

<p>Removing an element from an one element queue, leaves the queue empty</p>

<p>[e₇] <code class="language-plaintext highlighter-rouge">∀ x Q₀, is_empty Q₀ → dequeue (enqueue x Q₀) = empty</code></p>

<p>Dequeue enqueue order unimportant for a non-empty queue</p>

<p>[e₈] <code class="language-plaintext highlighter-rouge">∀ x Q₀, ¬is_empty Q₀ → dequeue (enqueue x Q₀) = enqueue x (dequeue Q₀)</code></p>

<p>In <a href="https://leanprover.github.io">lean 3</a> the simple queue can be captured through an Typeclass as follows:</p>

<pre><code class="language-Lean">class IQueue (α : Type u) (Q : Type u → Type u) :=
  --!`queue operations`--
  (empty:     Q α             )
  (is_empty:  Q α → bool      )
  (front:     Q α → option α  )
  (enqueue:     α → Q α → Q α )
  (dequeue:   Q α → Q α       )
  --!`queue contract`--
   
  (e₁ : is_empty empty = tt)
  (e₂ : ∀ x Q₀, is_empty (enqueue x Q₀) = ff)
  (e₃ : front empty = none)
  (e₄ : ∀ x Q₀,  is_empty Q₀ → front (enqueue x Q₀) = some x)
  (e₅ : ∀ x Q₀, ¬is_empty Q₀ → front (enqueue x Q₀) = front Q₀)
  (e₆ : dequeue empty = empty)
  (e₇ : ∀ x Q₀, is_empty Q₀ → dequeue (enqueue x Q₀) = empty)
  (e₈ : ∀ x Q₀, ¬is_empty Q₀ → dequeue (enqueue x Q₀) = enqueue x (dequeue Q₀))
</code></pre>]]></content><author><name></name></author><category term="formal" /><category term="lean3" /><summary type="html"><![CDATA[playing with typeclasses in lean]]></summary></entry></feed>